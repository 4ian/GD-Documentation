<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\Runtime\runtimegame.js - Game Develop JS Runtime API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.7.0/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap-responsive.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="Game Develop JS Runtime API" src="../assets/css/logo.png" style="max-height: 65%;" title="Game Develop JS Runtime API">
        
            Game Develop JS Runtime API
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/gdjs.EventsContext", "classes/gdjs.evtTools.camera", "classes/gdjs.evtTools.common", "classes/gdjs.evtTools.input", "classes/gdjs.evtTools.network", "classes/gdjs.evtTools.object", "classes/gdjs.evtTools.runtimeScene", "classes/gdjs.evtTools.sound", "classes/gdjs.evtTools.storage", "classes/gdjs.evtTools.string", "classes/gdjs.evtTools.window", "classes/gdjs.Force", "classes/gdjs.ImageManager", "classes/gdjs.Layer", "classes/gdjs.Polygon", "classes/gdjs.RuntimeAutomatism", "classes/gdjs.RuntimeGame", "classes/gdjs.RuntimeObject", "classes/gdjs.RuntimeScene", "classes/gdjs.Sound", "classes/gdjs.SoundManager", "classes/gdjs.SpriteAnimation", "classes/gdjs.SpriteAnimationFrame", "classes/gdjs.SpriteRuntimeObject", "classes/gdjs.Timer", "classes/gdjs.Variable", "classes/gdjs.VariablesContainer"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/gdjs.EventsContext.html">gdjs.EventsContext</a></li>
                    
                        <li><a href="../classes/gdjs.Force.html">gdjs.Force</a></li>
                    
                        <li><a href="../classes/gdjs.ImageManager.html">gdjs.ImageManager</a></li>
                    
                        <li><a href="../classes/gdjs.Layer.html">gdjs.Layer</a></li>
                    
                        <li><a href="../classes/gdjs.Polygon.html">gdjs.Polygon</a></li>
                    
                        <li><a href="../classes/gdjs.RuntimeAutomatism.html">gdjs.RuntimeAutomatism</a></li>
                    
                        <li><a href="../classes/gdjs.RuntimeGame.html">gdjs.RuntimeGame</a></li>
                    
                        <li><a href="../classes/gdjs.RuntimeObject.html">gdjs.RuntimeObject</a></li>
                    
                        <li><a href="../classes/gdjs.RuntimeScene.html">gdjs.RuntimeScene</a></li>
                    
                        <li><a href="../classes/gdjs.SoundManager.html">gdjs.SoundManager</a></li>
                    
                        <li><a href="../classes/gdjs.SpriteAnimation.html">gdjs.SpriteAnimation</a></li>
                    
                        <li><a href="../classes/gdjs.SpriteAnimationFrame.html">gdjs.SpriteAnimationFrame</a></li>
                    
                        <li><a href="../classes/gdjs.SpriteRuntimeObject.html">gdjs.SpriteRuntimeObject</a></li>
                    
                        <li><a href="../classes/gdjs.Timer.html">gdjs.Timer</a></li>
                    
                        <li><a href="../classes/gdjs.Variable.html">gdjs.Variable</a></li>
                    
                        <li><a href="../classes/gdjs.VariablesContainer.html">gdjs.VariablesContainer</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>..\Runtime\runtimegame.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/*
 * Game Develop JS Platform
 * Copyright 2013-2014 Florian Rival (Florian.Rival@gmail.com). All rights reserved.
 * This project is released under the GNU Lesser General Public License.
 */

/**
 * Represents a game being played.
 *
 * @constructor
 * @namespace gdjs
 * @class RuntimeGame
 * @param data The object (usually stored in data.json) containing the full project data
 * @param spec Optional object for specifiying additional options: {forceFullscreen: ...}
 */
gdjs.RuntimeGame = function(data, spec)
{
    //Safety check: Do gdjs initialization if not already done
    if ( gdjs.objectsTypes.keys.length === 0)
        gdjs.registerObjects();
    if ( gdjs.automatismsTypes.keys.length === 0)
        gdjs.registerAutomatisms();
    if ( gdjs.callbacksRuntimeSceneLoaded.length === 0 &amp;&amp;
         gdjs.callbacksRuntimeSceneUnloaded.length === 0 &amp;&amp;
         gdjs.callbacksObjectDeletedFromScene.length === 0)
        gdjs.registerGlobalCallbacks();

    this._variables = new gdjs.VariablesContainer(data.variables);
    this._data = data;
    this._imageManager = new gdjs.ImageManager(this);
    this._minFPS = data ? parseInt(data.properties.minFPS, 10) : 15;

    //Game loop management (see startStandardGameLoop method)
    this._notifySceneForResize = false; //When set to true, the current scene is notified that canvas size changed.

    //Rendering (see createStandardCanvas method)
    this._isFullscreen = false; //Used to track if the canvas is displayed as fullscreen (see setFullscreen method).
    this._forceFullscreen = spec.forceFullscreen || false; //If set to true, the canvas will always be displayed as fullscreen, even if _isFullscreen == false.
    this._renderer = null;
    this._canvasArea = null;
    this._defaultWidth = gdjs.projectData.properties.windowWidth; //Default size for scenes cameras
    this._defaultHeight = gdjs.projectData.properties.windowHeight;
    this._currentWidth = gdjs.projectData.properties.windowWidth; //Current size of the canvas
    this._currentHeight = gdjs.projectData.properties.windowHeight;
    this._keepRatio = true;
    this._reduceIfNeed = true;
    this._marginLeft = this._marginTop = this._marginRight = this._marginBottom = 0;

    if (navigator.isCocoonJS &amp;&amp; !this._forceFullscreen) {
        this._forceFullscreen = true;
        console.log(&quot;Forcing fullscreen for CocoonJS.&quot;);
    }
    if ( typeof intel != &quot;undefined&quot; ) {
        this._forceFullscreen = true;
        console.log(&quot;Forcing fullscreen for Intel XDK.&quot;);
    }

    //Inputs :
    this._pressedKeys = new Hashtable();
    this._pressedMouseButtons = new Array(5);
    this._mouseX = 0;
    this._mouseY = 0;
    this._mouseWheelDelta = 0;
};

/**
 * Get the variables of the runtimeGame.
 * @method getVariables
 * @return a variablesContainer object.
 */
gdjs.RuntimeGame.prototype.getVariables = function() {
	return this._variables;
};

gdjs.RuntimeGame.prototype.getImageManager = function() {
	return this._imageManager;
};

/**
 * Get the object containing the game data
 * @method getGameData
 * @return The object associated to the game.
 */
gdjs.RuntimeGame.prototype.getGameData = function() {
	return this._data;
};

/**
 * Get the data associated to a scene.
 *
 * @method getSceneData
 * @param sceneName The name of the scene. If not defined, the first scene will be returned.
 * @return The data associated to the scene.
 */
gdjs.RuntimeGame.prototype.getSceneData = function(sceneName) {
	var scene = undefined;
	gdjs.iterateOverArray(this._data.layouts, function(sceneData) {
		if ( sceneName === undefined || sceneData.name === sceneName ) {
			scene = sceneData;
			return false;
		}
	});

	if ( scene === undefined )
		console.warn(&quot;The game has no scene called \&quot;&quot;+sceneName+&quot;\&quot;&quot;);

	return scene;
};

/**
 * Check if a scene exists
 *
 * @method hasScene
 * @param sceneName The name of the scene to search.
 * @return true if the scene exists. If sceneName is undefined, true if the game has a scene.
 */
gdjs.RuntimeGame.prototype.hasScene = function(sceneName) {
	var isTrue = false;
	gdjs.iterateOverArray(this._data.layouts, function(sceneData) {
		if ( sceneName === undefined || sceneData.name == sceneName ) {
			isTrue = true;
			return false;
		}
	});

	return isTrue;
};

/**
 * Get the data associated to an external layout.
 *
 * @method getExternalLayoutData
 * @param name The name of the external layout.
 * @return The data associated to the external layout or null if not found.
 */
gdjs.RuntimeGame.prototype.getExternalLayoutData = function(name) {
    var externalLayout = null;
    gdjs.iterateOverArray(this._data.externalLayouts, function(layoutData) {
        if ( layoutData.name === name ) {
            externalLayout = layoutData;
            return false;
        }
    });

    return externalLayout;
};

/**
 * Get the data representing all the global objects of the game.
 * @method getInitialObjectsData
 * @return The data associated to the global objects.
 */
gdjs.RuntimeGame.prototype.getInitialObjectsData = function() {
	return this._data.objects;
};

/**
 * Should be called whenever a key is pressed
 * @method onKeyPressed
 * @param keyCode {Number} The key code associated to the key press.
 */
gdjs.RuntimeGame.prototype.onKeyPressed = function(keyCode) {
	this._pressedKeys.put(keyCode, true);
};

/**
 * Should be called whenever a key is released
 * @method onKeyReleased
 * @param keyCode {Number} The key code associated to the key release.
 */
gdjs.RuntimeGame.prototype.onKeyReleased = function(keyCode) {
	this._pressedKeys.put(keyCode, false);
};

/**
 * Return true if the key corresponding to keyCode is pressed.
 * @method isKeyPressed
 * @param keyCode {Number} The key code to be tested.
 */
gdjs.RuntimeGame.prototype.isKeyPressed = function(keyCode) {
	return this._pressedKeys.containsKey(keyCode) &amp;&amp; this._pressedKeys.get(keyCode);
};

/**
 * Return true if any key is pressed
 * @method anyKeyPressed
 */
gdjs.RuntimeGame.prototype.anyKeyPressed = function(keyCode) {
	var allKeys = this._pressedKeys.entries();

	for(var i = 0, len = allKeys.length;i&lt;len;++i) {
		if (allKeys[i][1]) {
			return true;
		}
	}

	return false;
};

/**
 * Should be called when the mouse is moved.&lt;br&gt;
 * Please note that the coordinates must be expressed relative to the view position.
 *
 * @method onMouseMove
 * @param x {Number} The mouse new X position
 * @param y {Number} The mouse new Y position
 */
gdjs.RuntimeGame.prototype.onMouseMove = function(x,y) {
	this._mouseX = x;
	this._mouseY = y;
};

/**
 * Get the mouse X position
 *
 * @method getMouseX
 * @return the mouse X position, relative to the game view.
 */
gdjs.RuntimeGame.prototype.getMouseX = function() {
	return this._mouseX;
};

/**
 * Get the mouse Y position
 *
 * @method getMouseY
 * @return the mouse Y position, relative to the game view.
 */
gdjs.RuntimeGame.prototype.getMouseY = function() {
	return this._mouseY;
};

gdjs.RuntimeGame.prototype.getDefaultWidth = function() {
    return this._defaultWidth;
};

gdjs.RuntimeGame.prototype.getDefaultHeight = function() {
    return this._defaultHeight;
};

/**
 * Change the default width of the game: It won&#x27;t affect the canvas size, but
 * new scene cameras will be created with this size.
 * @method setDefaultWidth
 * @param width {Number} The new default width
 */
gdjs.RuntimeGame.prototype.setDefaultWidth = function(width) {
    this._defaultWidth = width;
};

/**
 * Change the default height of the game: It won&#x27;t affect the canvas size, but
 * new scene cameras will be created with this size.
 * @method setDefaultHeight
 * @param height {Number} The new default height
 */
gdjs.RuntimeGame.prototype.setDefaultHeight = function(height) {
    this._defaultHeight = height;
};

/**
 * Change the size of the canvas displaying the game.
 * Note that if the canvas is fullscreen, it won&#x27;t be resized, but when going back to
 * non fullscreen mode, the requested size will be used.
 *
 * @method setCanvasSize
 * @param width {Number} The new width
 * @param height {Number} The new height
 */
gdjs.RuntimeGame.prototype.setCanvasSize = function(width, height) {
    this._currentWidth = width;
    this._currentHeight = height;

    this._resizeCanvas(this._renderer, this._canvasArea, this._isFullscreen,
        this._currentWidth, this._currentHeight);
    this._notifySceneForResize = true;
};

/**
 * Should be called whenever a mouse button is pressed
 * @method onMouseButtonPressed
 * @param buttonCode {Number} The mouse button code associated to the event.&lt;br&gt;0: Left button&lt;br&gt;1: Right button
 */
gdjs.RuntimeGame.prototype.onMouseButtonPressed = function(buttonCode) {
	this._pressedMouseButtons[buttonCode] = true;
};

/**
 * Should be called whenever a mouse button is released
 * @method onMouseButtonReleased
 * @param buttonCode {Number} The mouse button code associated to the event. ( See onMouseButtonPressed )
 */
gdjs.RuntimeGame.prototype.onMouseButtonReleased = function(buttonCode) {
	this._pressedMouseButtons[buttonCode] = false;
};

/**
 * Return true if the mouse button corresponding to buttonCode is pressed.
 * @method isMouseButtonPressed
 * @param buttonCode {Number} The mouse button code.&lt;br&gt;0: Left button&lt;br&gt;1: Right button
 */
gdjs.RuntimeGame.prototype.isMouseButtonPressed = function(buttonCode) {
	return this._pressedMouseButtons[buttonCode] !== undefined &amp;&amp; this._pressedMouseButtons[buttonCode];
};

/**
 * Should be called whenever the mouse wheel is used
 * @method onMouseWheel
 * @param wheelDelta {Number} The mouse wheel delta
 */
gdjs.RuntimeGame.prototype.onMouseWheel = function(wheelDelta) {
	this._mouseWheelDelta = wheelDelta;
};

/**
 * Return the mouse wheel delta
 * @method getMouseWheelDelta
 */
gdjs.RuntimeGame.prototype.getMouseWheelDelta = function() {
	return this._mouseWheelDelta;
};

/**
 * Return the minimal fps that must be guaranteed by the game.
 * ( Otherwise, game is slowed down ).
 * @method getMinimalFramerate
 */
gdjs.RuntimeGame.prototype.getMinimalFramerate = function() {
	return this._minFPS;
};

/**
 * Add the standard events handler.
 * Be sure that the game has a renderer (See createStandardRenderer).
 * @method bindStandardEvents
 */
gdjs.RuntimeGame.prototype.bindStandardEvents = function(window, document) {
    if (!this._renderer || !this._canvasArea) {
        console.log(&quot;Unable to bind events to the game! Be sure that there is a renderer and a canvas area associated to the game.&quot;);
        return;
    }

    var isMSIE = /*@cc_on!@*/0;
    this._renderer.view.style.cssText=&quot;idtkscale:&#x27;ScaleAspectFill&#x27;;&quot;; //CocoonJS support

    var game = this;
    document.onkeydown = function(e) {
        game.onKeyPressed(e.keyCode);
    };
    document.onkeyup = function(e) {
        game.onKeyReleased(e.keyCode);
    };
    this._renderer.view.onmousemove = function(e){
        var pos = [0,0];
        if (e.pageX) {
            pos[0] = e.pageX-game._canvasArea.offsetLeft;
            pos[1] = e.pageY-game._canvasArea.offsetTop;
        }
        else {
            pos[0] = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft-game._canvasArea.offsetLeft;
            pos[1] = e.clientY + document.body.scrollTop + document.documentElement.scrollTop-game._canvasArea.offsetTop;
        }

        //Handle the fact that the game is stretched to fill the canvas.
        pos[0] *= game.getDefaultWidth()/game._renderer.view.width;
        pos[1] *= game.getDefaultHeight()/game._renderer.view.height;

        game.onMouseMove(pos[0], pos[1]);
    };
    this._renderer.view.onmousedown = function(e){
        game.onMouseButtonPressed(e.button === 2 ? 1 : 0);
        if (window.focus !== undefined) window.focus();
        return false;
    };
    this._renderer.view.onmouseup = function(e){
        game.onMouseButtonReleased(e.button === 2 ? 1 : 0);
        return false;
    };
    this._renderer.view.onmouseout = function(e){
        game.onMouseButtonReleased(0);
        game.onMouseButtonReleased(1);
        game.onMouseWheel(0);
        return false;
    };
    window.addEventListener(&#x27;click&#x27;, function(e) {
        if (window.focus !== undefined) window.focus();
        e.preventDefault();
        return false;
    }, false);
    this._renderer.view.oncontextmenu = function(event) {
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
    this._renderer.view.onmousewheel = function (event){
        game.onMouseWheel(event.wheelDelta);
    };
    //Simulate mouse events when receiving touch events
    window.addEventListener(&#x27;touchmove&#x27;, function(e){
        e.preventDefault();
        if ( e.touches &amp;&amp; e.touches.length &gt; 0 ) {
            var pos = [0,0];
            if (e.touches[0].pageX) {
                pos[0] = e.touches[0].pageX-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].pageY-game._canvasArea.offsetTop;
            }
            else {
                pos[0] = e.touches[0].clientX + document.body.scrollLeft + document.documentElement.scrollLeft-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].clientY + document.body.scrollTop + document.documentElement.scrollTop-game._canvasArea.offsetTop;
            }

            //Handle the fact that the game is stretched to fill the canvas.
            pos[0] *= game.getDefaultWidth()/game._renderer.view.width;
            pos[1] *= game.getDefaultHeight()/game._renderer.view.height;

            game.onMouseMove(pos[0], pos[1]);
        }
    });
    window.addEventListener(&#x27;touchstart&#x27;, function(e){
        e.preventDefault();
        if ( e.touches &amp;&amp; e.touches.length &gt; 0 ) {
            var pos = [0,0];
            if (e.touches[0].pageX) {
                if ( isNaN(game._canvasArea.offsetLeft) ) {
                    game._canvasArea.offsetLeft = 0;
                    game._canvasArea.offsetTop = 0;
                }

                pos[0] = e.touches[0].pageX-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].pageY-game._canvasArea.offsetTop;
            }
            else {
                if ( isNaN(document.body.scrollLeft) ) {
                    document.body.scrollLeft = 0;
                    document.body.scrollTop = 0;
                }
                if ( document.documentElement === undefined || document.documentElement === null ) {
                    document.documentElement = {};
                }
                if ( isNaN(document.documentElement.scrollLeft) ) {
                    document.documentElement.scrollLeft = 0;
                    document.documentElement.scrollTop = 0;
                }
                if ( isNaN(game._canvasArea.offsetLeft) ) {
                    game._canvasArea.offsetLeft = 0;
                    game._canvasArea.offsetTop = 0;
                }
                pos[0] = e.touches[0].clientX + document.body.scrollLeft + document.documentElement.scrollLeft-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].clientY + document.body.scrollTop + document.documentElement.scrollTop-game._canvasArea.offsetTop;
            }

            //Handle the fact that the game is stretched to fill the canvas.
            pos[0] *= game.getDefaultWidth()/game._renderer.view.width;
            pos[1] *= game.getDefaultHeight()/game._renderer.view.height;

            game.onMouseMove(pos[0], pos[1]);
        }
        game.onMouseButtonPressed(0);
        return false;
    });
    window.addEventListener(&#x27;touchend&#x27;, function(e){
        e.preventDefault();
        if ( e.touches &amp;&amp; e.touches.length &gt; 0 ) {
            var pos = [0,0];
            if (e.touches[0].pageX) {
                pos[0] = e.touches[0].pageX-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].pageY-game._canvasArea.offsetTop;
            }
            else {
                pos[0] = e.touches[0].clientX + document.body.scrollLeft + document.documentElement.scrollLeft-game._canvasArea.offsetLeft;
                pos[1] = e.touches[0].clientY + document.body.scrollTop + document.documentElement.scrollTop-game._canvasArea.offsetTop;
            }

            //Handle the fact that the game is stretched to fill the canvas.
            pos[0] *= game.getDefaultWidth()/game._renderer.view.width;
            pos[1] *= game.getDefaultHeight()/game._renderer.view.height;

            game.onMouseMove(pos[0], pos[1]);
        }
        game.onMouseButtonReleased(0);
        return false;
    });
    //Hide the adress bar on handheld devices.
    window.addEventListener(&#x27;load&#x27;, function(e) {
        setTimeout(function() {
            if ( document.documentElement.clientWidth &lt; 600 ) {
                window.scrollTo(0, 1);
            }
        }, 1);
    }, false);
};

/**
 * Set if the aspect ratio must be kept when the game canvas is resized.
 */
gdjs.RuntimeGame.prototype.keepAspectRatio = function(enable) {
    if (this._keepRatio === enable) return;

    this._keepRatio = enable;
    this._resizeCanvas();
    this._notifySceneForResize = true;
};

/**
 * Change the margin that must be preserved around the game canvas.
 */
gdjs.RuntimeGame.prototype.setMargins = function(top, right, bottom, left) {
    if (this._marginTop === top &amp;&amp; this._marginRight === right &amp;&amp; this._marginBottom === bottom &amp;&amp;
        this._marginLeft === left)
        return;

    this._marginTop = top;
    this._marginRight = right;
    this._marginBottom = bottom;
    this._marginLeft = left;
    this._resizeCanvas();
    this._notifySceneForResize = true;
};

/**
 * De/activate fullscreen for the canvas rendering the game.
 * @method setFullScreen
 */
gdjs.RuntimeGame.prototype.setFullScreen = function(enable) {
    if (this._forceFullscreen) return;

    if (this._isFullscreen !== enable) {
        this._isFullscreen = !!enable;
        this._resizeCanvas();
        this._notifySceneForResize = true;

        if (this._isFullscreen) {
            if(document.documentElement.requestFullScreen) {
                document.documentElement.requestFullScreen();
            } else if(document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if(document.documentElement.webkitRequestFullScreen) {
                document.documentElement.webkitRequestFullScreen();
            }
        }
        else {
            if(document.cancelFullScreen) {
                document.cancelFullScreen();
            } else if(document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if(document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            }
        }
    }
};

/**
 * Create a standard canvas inside canvasArea.
 * The game keep a reference to this canvas and will renderer in it.
 *
 * @method createStandardCanvas
 */
gdjs.RuntimeGame.prototype.createStandardCanvas = function(canvasArea) {
    this._canvasArea = canvasArea;

    //Create the renderer and setup the rendering area
    this._renderer = PIXI.autoDetectRenderer(this._defaultWidth, this._defaultHeight);
    canvasArea.style[&quot;position&quot;] = &quot;absolute&quot;;
    canvasArea.appendChild(this._renderer.view); // add the renderer view element to the DOM
    canvasArea.tabindex=&quot;1&quot;; //Ensure that the canvas has the focus.
    canvasArea.style.overflow=&quot;hidden&quot;; //No scrollbar in any case.
    this._resizeCanvas();

    //Handle resize
    var game = this;
    window.addEventListener(&quot;resize&quot;, function() {
        game._resizeCanvas();
        game._notifySceneForResize = true;
    });

    return this._renderer;
};

/**
 * Resize the canvas, according to _isFullscreen, _forceFullscreen, _currentWidth,
 * _currentHeight, _marginTop, _marginLeft, _marginRight, _marginBottom, _keepRatio.
 *
 * If fullscreen is activated
 *
 * @method _resizeCanvas
 * @private
 * @static
 */
gdjs.RuntimeGame.prototype._resizeCanvas = function() {
    var keepRatio = this._keepRatio;

    var reduceIfNeed = this._reduceIfNeed;
    var isFullscreen = this._forceFullscreen || this._isFullscreen;
    var width = this._currentWidth;
    var height = this._currentHeight;
    var marginLeft = this._marginLeft;
    var marginTop = this._marginTop;
    var marginRight = this._marginRight;
    var marginBottom = this._marginBottom;
    var maxWidth = window.innerWidth-marginLeft-marginRight;
    var maxHeight = window.innerHeight-marginTop-marginBottom;
    if (maxWidth &lt; 0) maxWidth = 0;
    if (maxHeight &lt; 0) maxHeight = 0;

    if (isFullscreen &amp;&amp; !keepRatio) {
        width = maxWidth;
        height = maxHeight;
    } else if (isFullscreen &amp;&amp; keepRatio ||
        (reduceIfNeed &amp;&amp; (width &gt; maxWidth || height &gt; maxHeight))) {
        var factor = maxWidth/width;
        if (height*factor &gt; maxHeight) factor = maxHeight/height;

        width *= factor;
        height *= factor;
    }

    if (this._renderer.width !== width || this._renderer.height !== height)
        this._renderer.resize(width, height);

    this._canvasArea.style[&quot;top&quot;] = ((marginTop+(maxHeight-height)/2)+&quot;px&quot;);
    this._canvasArea.style[&quot;left&quot;] = ((marginLeft+(maxWidth-width)/2)+&quot;px&quot;);
    this._canvasArea.style.width = width+&quot;px&quot;;
    this._canvasArea.style.height = height+&quot;px&quot;;
};

/**
 * Load all assets, displaying progress in renderer.
 * @method loadAllAssets
 */
gdjs.RuntimeGame.prototype.loadAllAssets = function(callback) {

    //Load all assets
    var loadingStage = new PIXI.Stage();
    var text = new PIXI.Text(&quot; &quot;, {font: &quot;bold 60px Arial&quot;, fill: &quot;#FFFFFF&quot;, align: &quot;center&quot;});
    loadingStage.addChild(text);
    text.position.x = this._renderer.width/2-50;
    text.position.y = this._renderer.height/2;
    var loadingCount = 0;

    var assets = [];
    gdjs.iterateOverArray(gdjs.projectData.resources.resources, function(res) {
        if ( res.file ) assets.push(res.file);
    });

    var game = this;
    if ( assets.length !== 0 ) {
        var assetLoader = new PIXI.AssetLoader(assets);
        assetLoader.onComplete = onAssetsLoaded;
        assetLoader.onProgress = onAssetsLoadingProgress;
        assetLoader.load();
    }
    else {
        onAssetsLoaded();
    }

    function onAssetsLoaded() {
        callback();
    }

    function onAssetsLoadingProgress() {
        game._renderer.render(loadingStage);
        loadingCount++;
        text.setText(Math.floor(loadingCount/assets.length*100) + &quot;%&quot;);
    }
};

/**
 * Launch the game, displayed in the renderer associated to the game (see createStandardCanvas).&lt;br&gt;
 * The method returns when the game is closed.
 * @method startStandardGameLoop
 */
gdjs.RuntimeGame.prototype.startStandardGameLoop = function() {

    if ( !this.hasScene() ) {
        console.log(&quot;The game has no scene.&quot;);
        return;
    }

    //Create the scene to be played
    var currentScene = new gdjs.RuntimeScene(this, this._renderer);
    var firstSceneName = gdjs.projectData.firstLayout;
    var firstsceneData = this.hasScene(firstSceneName) ? this.getSceneData(firstSceneName) : this.getSceneData();

    currentScene.loadFromScene(firstsceneData);

    requestAnimFrame(gameLoop);

    //The standard game loop
    var game = this;
    function gameLoop() {

        //Manage resize events.
        if ( game._notifySceneForResize ) {
            currentScene.onCanvasResized();
            game._notifySceneForResize = false;
        }

        //Render and step the scene.
        if ( !currentScene.renderAndStep() ) {
            //Something special was requested by the current scene.
            if ( currentScene.gameStopRequested() )
                postGameScreen();
            else {
                var nextSceneName = currentScene.getRequestedScene();
                currentScene = new gdjs.RuntimeScene(game, game._renderer);
                currentScene.loadFromScene(game.getSceneData(nextSceneName));
                requestAnimFrame( gameLoop );
            }
        }
        else {
            requestAnimFrame( gameLoop );
        }
    }
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
